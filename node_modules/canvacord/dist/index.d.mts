import { Font as Font$1, SatoriOptions } from 'satori';
import * as stream from 'stream';
import { Readable } from 'stream';
import * as _napi_rs_canvas from '@napi-rs/canvas';
import { Canvas, AvifConfig, SKRSContext2D, Image } from '@napi-rs/canvas';
import { EncoderOptions } from '@skyra/gifenc';
import * as http from 'http';
import { PngEncodeOptions, AvifConfig as AvifConfig$1 } from '@napi-rs/image';
import * as React$1 from 'react';
import { CSSProperties } from 'react';
import { ClassNameValue } from 'tailwind-merge';

declare class Font {
    data: Buffer;
    alias: string;
    /**
     * Creates and registers a new Font instance for both canvas and builder apis.
     * @param data The font data
     * @param [alias] The font alias. If not provided, a random UUID will be used.
     *
     * const data = await readFile('path/to/font.ttf');
     * const font = new Font(data, 'my-font');
     
     */
    constructor(data: Buffer, alias?: string);
    /**
     * The alias for this font.
     */
    get name(): string;
    /**
     * Returns the font data that includes information such as the font name, weight, data, and style.
     */
    getData(): Font$1;
    /**
     * String representation of this font.
     */
    toString(): string;
    /**
     * JSON representation of this font.
     */
    toJSON(): Font$1;
    /**
     * Creates a new Font instance from a file.
     * @param path The path to the font file
     * @param [alias] The font alias. If not provided, a random UUID will be used.
     *
     * const font = await Font.fromFile('path/to/font.ttf', 'my-font');
     
     */
    static fromFile(path: string, alias?: string): Promise<Font>;
    /**
     * Creates a new Font instance from a file synchronously.
     * @param path The path to the font file
     * @param [alias] The font alias. If not provided, a random UUID will be used.
     *
     * const font = Font.fromFileSync('path/to/font.ttf', 'my-font');
     */
    static fromFileSync(path: string, alias?: string): Font;
    /**
     * Creates a new Font instance from a buffer.
     * @param buffer The buffer containing the font data
     * @param [alias] The font alias. If not provided, a random UUID will be used.
     *
     * const buffer = await readFile('path/to/font.ttf');
     * const font = Font.fromBuffer(buffer, 'my-font');
     
     */
    static fromBuffer(buffer: Buffer, alias?: string): Font;
    /**
     * Loads the default font bundled with this package.
     *
     * const font = Font.loadDefault();
     
     */
    static loadDefault(): Font;
    /**
     * Unloads the font from the canvas and builder apis.
     */
    unloadAll(): void;
}

declare const FontFactory: Map<string, Font>;
/**
 * The image assets factory.
 */
declare const ImageFactory: {
    AFFECT: string;
    BATSLAP: string;
    BEAUTIFUL: string;
    BED: string;
    BOTBADGE: string;
    CAPTCHA: string;
    CHANGEMYMIND: string;
    CLYDE: string;
    DELETE: string;
    DISCORD: string;
    DISTRACTED: string;
    DND: string;
    FACEPALM: string;
    RAINBOW: string;
    HITLER: string;
    IDLE: string;
    IMPOSTER: string;
    IMPOSTERWITH: string;
    JAIL: string;
    JOKEOVERHEAD: string;
    KICK: string;
    KISS: string;
    KO: string;
    OFFLINE: string;
    OHNO: string;
    ONLINE: string;
    OPINION: string;
    PHUB: string;
    PUNCH: string;
    RIP: string;
    SHIT: string;
    SNOWFLAKE: string;
    SPANK: string;
    TOBECONTINUED: string;
    TRASH: string;
    TRIGGERED: string;
    WANTED: string;
    WASTED: string;
    WELCOMEBG: string;
    YOUTUBE: string;
};

type EncodingFormat = "png" | "jpeg" | "webp" | "avif" | "raw";
declare abstract class Encodable {
    /**
     * Returns the canvas instance by applying the steps.
     */
    abstract getFinalCanvas(): Promise<Canvas>;
    /**
     * Encodes the canvas to a buffer.
     */
    encode(): Promise<Buffer>;
    /**
     * Encodes the canvas to a png buffer.
     * @param format The encoding format - `png`
     */
    encode(format: "png"): Promise<Buffer>;
    /**
     * Encodes the canvas to a jpeg or webp buffer.
     * @param format The encoding format - `jpeg` or `webp`
     * @param [options] The quality of the image
     */
    encode(format: "jpeg" | "webp", options?: number): Promise<Buffer>;
    /**
     * Encodes the canvas to an avif buffer.
     * @param format The encoding format - `avif`
     * @param [options] The encoding options
     */
    encode(format: "avif", options?: AvifConfig): Promise<Buffer>;
}

interface ImageGenerationStep {
    /**
     * The image to render.
     */
    image?: ImgenStep[];
    /**
     * The text to render.
     */
    text?: TextGenerationStep[];
    /**
     * The custom steps to apply to the canvas.
     */
    custom?: CustomGenerationStep[];
    /**
     * The function to call before processing this step.
     */
    preprocess?: (canvas: Canvas, ctx: SKRSContext2D, step: ImageGenerationStep) => Awaited<void>;
    /**
     * The function to call when processing this step.
     */
    process?: (canvas: Canvas, ctx: SKRSContext2D, step: ImageGenerationStep) => Awaited<void>;
    /**
     * The function to call after processing has finished.
     */
    postprocess?: (canvas: Canvas, ctx: SKRSContext2D, step: ImageGenerationStep) => Awaited<void>;
}
interface CustomGenerationStep {
    /**
     * The function to call when processing this step.
     */
    process: (canvas: Canvas, ctx: SKRSContext2D, step: ImageGenerationStep) => Awaited<void>;
}
interface ImgenStep {
    /**
     * The image to render.
     */
    source: TemplateImage;
    /**
     * The x position of the image.
     */
    x: number;
    /**
     * The y position of the image.
     */
    y: number;
    /**
     * The width of the image.
     */
    width?: number;
    /**
     * The height of the image.
     */
    height?: number;
    /**
     * The function to call before processing this step.
     */
    preprocess?: (canvas: Canvas, ctx: SKRSContext2D, source: ImgenStep) => Awaited<void>;
    /**
     * The function to call when processing this step.
     */
    process?: (canvas: Canvas, ctx: SKRSContext2D, source: ImgenStep) => Awaited<void>;
    /**
     * The function to call after processing has finished.
     */
    postprocess?: (canvas: Canvas, ctx: SKRSContext2D, source: ImgenStep) => Awaited<void>;
}
interface TextGenerationStep {
    /**
     * The text to render.
     */
    value: string;
    /**
     * The font of the text.
     */
    font: string;
    /**
     * The color of the text.
     */
    color: string;
    /**
     * Whether to stroke the text.
     */
    stroke?: boolean;
    /**
     * The x position of the text.
     */
    x: number;
    /**
     * The y position of the text.
     */
    y: number;
    /**
     * The maximum width of the text.
     */
    maxWidth?: number;
    /**
     * The line height of the text.
     */
    lineHeight?: number;
    /**
     * The line width of the text.
     */
    lineWidth?: number;
    /**
     * The alignment of the text.
     */
    align?: "left" | "center" | "right";
    /**
     * The baseline of the text.
     */
    baseline?: "top" | "middle" | "bottom";
    /**
     * The directionality of the text.
     */
    direction?: "inherit" | "ltr" | "rtl";
    /**
     * The function to call before processing this step.
     */
    preprocess?: (canvas: Canvas, ctx: SKRSContext2D, text: TextGenerationStep) => Awaited<void>;
    /**
     * The function to call when processing this step.
     */
    process?: (canvas: Canvas, ctx: SKRSContext2D, text: TextGenerationStep) => Awaited<void>;
    /**
     * The function to call after processing has finished.
     */
    postprocess?: (canvas: Canvas, ctx: SKRSContext2D, text: TextGenerationStep) => Awaited<void>;
}
/**
 * The template to use for image generation.
 */
interface IImageGenerationTemplate {
    /**
     * The width of the template.
     */
    width?: number;
    /**
     * The height of the template.
     */
    height?: number;
    /**
     * The steps to apply to the canvas.
     */
    steps: ImageGenerationStep[];
    /**
     * The gif options.
     */
    gif?: EncoderOptions;
}
declare class ImageGenerationTemplate implements IImageGenerationTemplate {
    readonly width?: number | undefined;
    readonly height?: number | undefined;
    /**
     * The steps to apply to the canvas.
     */
    steps: ImageGenerationStep[];
    /**
     * The gif options.
     */
    gif?: EncoderOptions;
    /**
     * Creates a new ImageGenerationTemplate instance from a template.
     * @param template The template to use
     * @returns The created template
     */
    static from(template: IImageGenerationTemplate): ImageGenerationTemplate;
    /**
     * Creates a new ImageGenerationTemplate instance.
     * @param width The width of the template
     * @param height The height of the template
     */
    constructor(width?: number | undefined, height?: number | undefined);
    /**
     * Sets the steps. This will overwrite any existing steps.
     * @param steps The steps to set
     */
    setSteps(steps: ImageGenerationStep[]): this;
    /**
     * Sets the gif options.
     * @param options The gif options
     */
    setGifOptions(options?: EncoderOptions): this;
    /**
     * Returns whether the template is a gif.
     */
    isGif(): boolean;
    /**
     * Adds a step to the template.
     * @param step The step to add
     */
    addStep(step: ImageGenerationStep): this;
    /**
     * Adds steps to the template.
     * @param steps The steps to add
     */
    addSteps(steps: ImageGenerationStep[]): this;
    /**
     * Clears the steps.
     */
    clearSteps(): this;
    /**
     * Returns whether the size is inferrable.
     */
    isInferrable(): boolean;
    /**
     * Returns the width of the template.
     */
    getWidth(): number | undefined;
    /**
     * Returns the height of the template.
     */
    getHeight(): number | undefined;
    /**
     * Returns the JSON representation of the template.
     */
    toJSON(): IImageGenerationTemplate;
}
declare class ImageGen extends Encodable {
    #private;
    template: ImageGenerationTemplate;
    private _canvas;
    /**
     * Creates a new ImageGen instance.
     * @param template The template to use
     */
    constructor(template: ImageGenerationTemplate);
    /**
     * Adds a step to the template.
     * @param step The step to add
     */
    addStep(step: ImageGenerationStep): this;
    /**
     * Adds steps to the template.
     * @param steps The steps to add
     */
    addSteps(steps: ImageGenerationStep[]): this;
    /**
     * Sets the gif options.
     * @param options The gif options
     */
    setGifOptions(options?: EncoderOptions): this;
    /**
     * Returns whether the template is a gif.
     */
    isGif(): boolean;
    /**
     * Generates a readable stream containing GIF data by applying the steps.
     */
    generateGif(): Promise<stream.Readable>;
    /**
     * Renders the image by applying the steps.
     */
    render(): Promise<this>;
    /**
     * Returns the canvas instance by applying the steps.
     */
    getFinalCanvas(): Promise<Canvas>;
}
/**
 * Creates a new image generator.
 * @param template The template to use
 */
declare function createImageGenerator(template: ImageGenerationTemplate): ImageGen;

/**
 * The element initialization options.
 */
type ElementInit = {
    type: string;
    props: Record<string, unknown>;
    key?: React$1.Key | null;
    children?: any;
};
/**
 * The JSX element.
 */
declare class Element {
    /**
     * The type of the element.
     */
    type: string;
    /**
     * The props of the element.
     */
    props: Record<string, unknown>;
    /**
     * The key of the element.
     */
    key: React$1.Key | null;
    /**
     * The children of the element.
     */
    children?: any;
    /**
     * Creates a new JSX element.
     * @param _init The initialization options
     */
    constructor(_init: ElementInit);
}
/**
 * The JSX factory for canvacord jsx.
 */
declare const JSX$1: {
    /**
     * The JSX element instance.
     */
    Element: typeof Element;
    /**
     * Creates a new JSX element.
     * @param type The type of the element
     * @param props The props of the element
     * @param children The children of the element
     * @returns The created element
     */
    createElement(type: string | Element, props: Record<string, unknown>, ...children: Element[]): Element;
    /**
     * Creates a new JSX fragment.
     * @param children The children of the fragment
     */
    Fragment({ children }: {
        children: Element[] | string;
    }): Element;
};
/**
 * Renders the components.
 */
declare function render(components: (Node | Element | unknown)[]): Element[];

type Stylable = {
    style: CSSPropertiesLike;
    className?: string;
} | string;
/**
 * The CSS properties like object.
 */
type CSSPropertiesLike<K extends string | number | symbol = string> = Record<K, CSSProperties>;
/**
 * Performs object cleanup by deleting all undefined properties that could interfere with builder methods.
 */
declare const performObjectCleanup: (obj: Record<string, any>, deep?: boolean) => void;
declare class StyleSheet extends null {
    private constructor();
    /**
     * Creates a new CSSPropertiesLike object.
     */
    static create<O extends CSSPropertiesLike, K extends keyof O>(styles: CSSPropertiesLike<K>): CSSPropertiesLike<K>;
    /**
     * Composes two CSSPropertiesLike objects.
     */
    static compose(style1: CSSProperties, style2: CSSProperties): CSSProperties;
    /**
     * Flattens an array of CSSPropertiesLike objects.
     */
    static flatten(style: CSSProperties[]): CSSProperties;
    /**
     * Merges multiple tailwind-like class names into appropriate class names.
     */
    static cn(...classes: ClassNameValue[]): string;
    /**
     * Returns the className string from stylable data.
     */
    static tw(data?: Stylable): string;
    /**
     * Returns the style object from stylable data.
     */
    static css(data?: Stylable): CSSPropertiesLike<string>;
}

/**
 * The options for rendering the svg.
 */
type RenderSvgOptions = PngEncodeOptions | AvifConfig$1 | number | null;
declare class CanvacordImage {
    data: Buffer;
    mime: string;
    constructor(data: Buffer, mime: string);
    toBase64(): string;
    toDataURL(): string;
}

/**
 * The supported image sources. It can be a buffer, a readable stream, a string, a URL instance or an Image instance.
 */
type ImageSource = CanvacordImage | Buffer | ArrayBuffer | Uint16Array | Uint32Array | Uint8Array | Uint8ClampedArray | SharedArrayBuffer | Readable | string | URL | Image;
/**
 * The options for loading an image.
 */
interface LoadImageOptions {
    /**
     * The headers to use when downloading the image.
     */
    headers?: Record<string, string>;
    /**
     * The maximum number of redirects to follow.
     */
    maxRedirects?: number;
    /**
     * Other request options to use when downloading the image.
     */
    requestOptions?: http.RequestOptions;
}
/**
 * Loads an image from the specified source.
 * @param source The image source
 * @param [options] The options for loading the image
 */
declare function loadImage(source: ImageSource, options?: LoadImageOptions): Promise<CanvacordImage>;

declare class TemplateImage {
    #private;
    source: ImageSource;
    /**
     * Creates a new TemplateImage instance.
     * @param source The image source
     *
     * const image = new TemplateImage('https://example.com/image.png');
     
     */
    constructor(source: ImageSource);
    /**
     * Whether this image has been resolved.
     */
    resolved(): boolean;
    /**
     * Resolves this image to consumable form.
     */
    resolve(): Promise<Image>;
}
/**
 * Creates a new template from the provided template.
 * @param template The template to create from
 */
declare const createTemplate: <F extends (...args: any[]) => any, P extends Parameters<F>>(cb: (...args: P) => IImageGenerationTemplate) => (...args: P) => ImageGenerationTemplate;
/**
 * The built-in template factory.
 */
declare const TemplateFactory: {
    Affect: (image: ImageSource) => ImageGenerationTemplate;
    Triggered: (image: ImageSource) => ImageGenerationTemplate;
    Fuse: (destination: ImageSource, source: ImageSource) => ImageGenerationTemplate;
    Kiss: (image1: ImageSource, image2: ImageSource) => ImageGenerationTemplate;
    Spank: (image1: ImageSource, image2: ImageSource) => ImageGenerationTemplate;
    Slap: (image1: ImageSource, image2: ImageSource) => ImageGenerationTemplate;
    Beautiful: (image: ImageSource) => ImageGenerationTemplate;
    Facepalm: (image: ImageSource) => ImageGenerationTemplate;
    Rainbow: (image: ImageSource) => ImageGenerationTemplate;
    Rip: (image: ImageSource) => ImageGenerationTemplate;
    Trash: (image: ImageSource) => ImageGenerationTemplate;
    Hitler: (image: ImageSource) => ImageGenerationTemplate;
    Distracted: (image1: ImageSource, image2: ImageSource, image3?: ImageSource | null | undefined) => ImageGenerationTemplate;
    Colorfy: (image: ImageSource, color: string) => ImageGenerationTemplate;
    Jail: (image: ImageSource, greyscale?: boolean | undefined) => ImageGenerationTemplate;
    Bed: (image1: ImageSource, image2: ImageSource) => ImageGenerationTemplate;
    JokeOverHead: (image: ImageSource) => ImageGenerationTemplate;
    Delete: (image: ImageSource) => ImageGenerationTemplate;
    Wanted: (image: ImageSource) => ImageGenerationTemplate;
    Wasted: (image: ImageSource) => ImageGenerationTemplate;
    Shit: (image: ImageSource) => ImageGenerationTemplate;
};

/**
 * The bundled fonts in this package.
 */
declare const Fonts: {
    /**
     * Geist sans font
     * @see https://vercel.com/font/sans
     */
    readonly Geist: Buffer;
};

declare class BuilderOptionsManager<T extends Record<string, any>> {
    private options;
    /**
     * Creates a new builder options manager.
     * @param options The options to use
     */
    constructor(options?: T);
    /**
     * Returns the options.
     */
    getOptions(): T;
    /**
     * Sets the options. This will override the previous options.
     * @param options The options to use
     */
    setOptions(options: T): void;
    /**
     * Get an option by name.
     * @param key The option name
     * @returns The option value
     */
    get<K extends keyof T>(key: K): T[K];
    /**
     * Set an option by name.
     * @param key The option name
     * @param value The option value
     */
    set<K extends keyof T>(key: K, value: T[K]): void;
    /**
     * Merge new data to old data on an option by name.
     */
    merge<K extends keyof T>(key: K, value: Partial<T[K]>): void;
}

type GraphemeProvider = Record<string, string>;
declare const createEmojiProvider: (builder: (code: string) => string) => GraphemeProvider;
declare const BuiltInGraphemeProvider: {
    Twemoji: GraphemeProvider;
    FluentEmojiHighContrast: GraphemeProvider;
    FluentEmojiFlat: GraphemeProvider;
    FluentEmojiColor: GraphemeProvider;
    Openmoji: GraphemeProvider;
    Noto: GraphemeProvider;
    Blobmoji: GraphemeProvider;
    None: GraphemeProvider;
};
declare const EmojiCache: Map<string, string>;
/**
 * The builder template.
 */
interface BuilderTemplate {
    /**
     * The components of this template.
     */
    components: Array<Node | Element>;
    /**
     * The width of this template.
     */
    width: number;
    /**
     * The height of this template.
     */
    height: number;
    /**
     * The style of this template.
     */
    style?: CSSProperties;
}
/**
 * The build output format.
 */
type BuildFormat = "svg" | "png" | "avif" | "jpeg" | "webp";
/**
 * The builder build options.
 */
type BuilderBuildOptions = {
    /**
     * The output format.
     */
    format?: BuildFormat;
    /**
     * The options for this build.
     */
    options?: RenderSvgOptions;
    /**
     * The abort signal.
     */
    signal?: AbortSignal;
} & SatoriOptions;
/**
 * The builder node.
 */
interface Node {
    /**
     * Convert this node to element.
     */
    toElement(): Element;
}
declare class Builder<T extends Record<string, any> = Record<string, unknown>> {
    #private;
    width: number;
    height: number;
    /**
     * The tailwind subset to apply to this builder.
     */
    tw: string;
    /**
     * The components of this builder.
     */
    components: (Node | Element)[];
    /**
     * The options manager of this builder.
     */
    options: BuilderOptionsManager<T>;
    /**
     * The grapheme provider of this builder.
     */
    graphemeProvider: GraphemeProvider;
    /**
     * Create a new builder.
     * @param width the width of this builder.
     * @param height the height of this builder.
     */
    constructor(width: number, height: number);
    /**
     * Bootstrap this builder with data.
     */
    bootstrap(data: T): void;
    /**
     * Adjust the canvas size.
     */
    adjustCanvas(): this;
    /**
     * Get the style of this builder.
     */
    get style(): CSSProperties;
    /**
     * Set the style of this builder.
     */
    set style(newStyle: CSSProperties);
    /**
     * Add component to this builder.
     * @param component the component to add.
     */
    addComponent<T extends Node | Element>(component: T | T[]): this;
    /**
     * Set grapheme image provider for this builder.
     */
    setGraphemeProvider(provider: GraphemeProvider): this;
    /**
     * Set the style of this builder.
     * @param newStyle the new style.
     */
    setStyle(newStyle: CSSProperties): this;
    private _render;
    /**
     * Render this builder.
     */
    render(): Promise<React.ReactNode>;
    /**
     * Convert this builder into an image.
     * @param options the build options.
     * @returns the image buffer or svg string.
     */
    build(options?: Partial<BuilderBuildOptions>): Promise<string | Buffer>;
    /**
     * Create a builder from builder template.
     */
    static from(template: BuilderTemplate): Builder<Record<string, unknown>>;
}

interface LeaderboardProps {
    /**
     * The background image.
     */
    background: ImageSource | null;
    /**
     * The background color.
     */
    backgroundColor: string;
    /**
     * The header of this leaderboard ui.
     */
    header?: {
        /**
         * The title of this leaderboard ui.
         */
        title: string;
        /**
         * The subtitle of this leaderboard ui.
         */
        subtitle: string;
        /**
         * The image of this leaderboard ui.
         */
        image: ImageSource;
    };
    /**
     * The players of this leaderboard ui.
     */
    players: {
        /**
         * The display name of this player.
         */
        displayName: string;
        /**
         * The username of this player.
         */
        username: string;
        /**
         * The level of this player.
         */
        level: number;
        /**
         * The xp of this player.
         */
        xp: number;
        /**
         * The rank of this player.
         */
        rank: number;
        /**
         * The avatar of this player.
         */
        avatar: ImageSource;
    }[];
    /**
     * The text values of this leaderboard ui.
     */
    text: {
        level: string;
        xp: string;
        rank: string;
    };
    /**
     * Whether or not to abbreviate the numeric values.
     */
    abbreviate: boolean;
}
declare const LeaderboardVariants: {
    readonly Default: "default";
    readonly Horizontal: "horizontal";
};
type LeaderboardVariants = (typeof LeaderboardVariants)[keyof typeof LeaderboardVariants];
declare class LeaderboardBuilder extends Builder<LeaderboardProps> {
    variant?: LeaderboardVariants;
    /**
     * Create a new leaderboard ui builder
     */
    constructor();
    /**
     * Set the ui variant for this leaderboard
     * @param variant ui type
     */
    setVariant(variant: LeaderboardVariants): this;
    /**
     * Set background for this leaderboard ui
     * @param background background image
     */
    setBackground(background: ImageSource): this;
    /**
     * Set background color for this leaderboard ui
     * @param color background color
     */
    setBackgroundColor(color: string): this;
    /**
     * Set header for this leaderboard ui
     * @param data header data
     */
    setHeader(data: LeaderboardProps["header"] & {}): this;
    /**
     * Set players for this leaderboard ui. The canvas size will be adjusted automatically based on the number of players.
     * @param players players data
     */
    setPlayers(players: LeaderboardProps["players"]): this;
    /**
     * Configures the text renderer for this leaderboard.
     * @param config The configuration for this leaderboard.
     */
    setTextStyles(config: Partial<LeaderboardProps["text"]>): this;
    /**
     * Render this leaderboard ui on the canvas
     */
    render(): Promise<JSX.Element>;
    /**
     * Render players ui on the canvas
     */
    renderDefaultPlayers(players: JSX.Element[]): JSX.Element;
    /**
     * Render top players ui on the canvas
     */
    renderDefaultTop({ avatar, displayName, level, rank, username, xp, }: LeaderboardProps["players"][number]): Promise<JSX.Element>;
    /**
     * Render player ui on the canvas
     */
    renderDefaultPlayer({ avatar, displayName, level, rank, username, xp, }: LeaderboardProps["players"][number]): Promise<JSX.Element>;
    renderDefaultVariant(): Promise<JSX.Element>;
    renderHorizontalPlayer({ avatar, displayName, level, rank, username, xp, }: LeaderboardProps["players"][number]): Promise<JSX.Element>;
    renderHorizontalVariant(): Promise<JSX.Element>;
}

declare const RankCardUserStatus: {
    readonly Online: "online";
    readonly Idle: "idle";
    readonly DoNotDisturb: "dnd";
    readonly Offline: "offline";
    readonly Streaming: "streaming";
    readonly None: "none";
    readonly Invisible: "invisible";
};
type RankCardUserStatus = (typeof RankCardUserStatus)[keyof typeof RankCardUserStatus];
type StatusData = RankCardUserStatus;
interface RankCardProps {
    handle: string | null;
    username: string | null;
    avatar: string;
    status: RankCardUserStatus | StatusData | null;
    currentXP: number | null;
    requiredXP: number | null;
    rank: number | null;
    level: number | null;
    backgroundColor: string;
    overlay: boolean | number | string;
    abbreviate: boolean;
    calculateProgress: (current: number, required: number) => number;
    texts: Partial<{
        level: string;
        xp: string;
        rank: string;
    }>;
    styles: Partial<{
        container: Stylable;
        background: Stylable;
        overlay: Stylable;
        avatar: Partial<{
            container: Stylable;
            image: Stylable;
            status: Stylable;
        }>;
        username: Partial<{
            container: Stylable;
            name: Stylable;
            handle: Stylable;
        }>;
        progressbar: Partial<{
            container: Stylable;
            thumb: Stylable;
            track: Stylable;
        }>;
        statistics: Partial<{
            container: Stylable;
            level: Partial<{
                container: Stylable;
                text: Stylable;
                value: Stylable;
            }>;
            xp: Partial<{
                container: Stylable;
                text: Stylable;
                value: Stylable;
            }>;
            rank: Partial<{
                container: Stylable;
                text: Stylable;
                value: Stylable;
            }>;
        }>;
    }>;
}

/**
 * The rank card builder props.
 */
interface RankCardBuilderProps extends Omit<RankCardProps, "avatar" | "backgroundColor"> {
    avatar: ImageSource;
    background: ImageSource;
    backgroundCrop?: Partial<{
        x: number;
        y: number;
        width: number;
        height: number;
    }>;
    fonts: Partial<{
        username: Partial<{
            name: string;
            handle: string;
        }>;
        progress: Partial<{
            level: Partial<{
                text: string;
                value: string;
            }>;
            xp: Partial<{
                text: string;
                value: string;
            }>;
            rank: Partial<{
                text: string;
                value: string;
            }>;
        }>;
    }>;
}
declare class RankCardBuilder extends Builder<RankCardBuilderProps> {
    /**
     * Creates a new rank card builder.
     * @example
     * const card = new RankCardBuilder()
     *     .setUsername('kiki')
     *     .setDisplayName('Kiki')
     *     .setDiscriminator('1234')
     *     .setAvatar('...')
     *     .setCurrentXP(300)
     *     .setRequiredXP(600)
     *     .setLevel(2)
     *     .setRank(5)
     *     .setStatus('online');
     *
     * const pngBuffer = await card.build({
     *   format: 'png'
     * });
     */
    constructor();
    /**
     * Sets the fonts to be used for this rank card.
     * @param fontConfig The fonts to be used for this rank card.
     */
    setFonts(fontConfig: Required<RankCardBuilderProps["fonts"]>): this;
    /**
     * Sets the avatar for this rank card.
     * @param image The avatar for this rank card.
     */
    setAvatar(image: ImageSource): this;
    /**
     * Sets the background for this rank card.
     * @param image The background for this rank card.
     */
    setBackground(image: ImageSource): this;
    /**
     * Sets the status for this rank card.
     * @param status The status for this rank card.
     */
    setStatus(status: RankCardUserStatus | StatusData): this;
    /**
     * Sets the username for this rank card.
     * @param name The username for this rank card.
     */
    setDisplayName(name: string): this;
    /**
     * Sets the handle name for this rank card.
     * @param name The handle name for this rank card.
     */
    setUsername(name: string): this;
    /**
     * Set overlay for this rank card.
     */
    setOverlay(overlay: RankCardProps["overlay"]): this;
    /**
     * Sets the current xp for this rank card.
     * @param xp The current xp for this rank card.
     */
    setCurrentXP(xp: number): this;
    /**
     * Sets the required xp for this rank card.
     * @param xp The required xp for this rank card.
     */
    setRequiredXP(xp: number): this;
    /**
     * Sets the level of this rank card.
     * @param level The level of this rank card.
     */
    setLevel(level: number): this;
    /**
     * Sets the rank of this rank card.
     * @param rank The rank of this rank card.
     */
    setRank(rank: number): this;
    /**
     * Configures the renderer for this rank card.
     * @param config The configuration for this rank card.
     */
    setStyles(config: Partial<RankCardBuilderProps["styles"]>): this;
    /**
     * Set background crop for this rank card.
     */
    setBackgroundCrop(pos: Partial<RankCardBuilderProps["backgroundCrop"]>): this;
    /**
     * Configures the texts for this rank card.
     * @param config The configuration for this rank card.
     */
    setTextStyles(config: Partial<RankCardBuilderProps["texts"]>): this;
    /**
     * Sets the progress calculator for this rank card. The value returned by this calculator defines the width of the progress bar.
     * Valid range is 0-100. Returning a number less than 0 or greater than 100 will be clamped within this range, or invalid values will result in 0% width.
     * @param calc The progress calculator for this rank card.
     */
    setProgressCalculator(calc: RankCardProps["calculateProgress"]): this;
    /**
     * Renders this rank card into the canvas.
     */
    render(): Promise<JSX.Element>;
}

/**
 * Creates a canvas image from the image source.
 * @param img The image source
 * @returns The canvas image
 *
 * const image = await createCanvasImage('https://example.com/image.png');
 */
declare const createCanvasImage: (img: ImageSource) => Promise<_napi_rs_canvas.Image>;
/**
 * The steps to apply to the canvas.
 * @param ctx The canvas context
 */
type ContextManipulationStep = (ctx: SKRSContext2D) => Awaited<void>;

declare abstract class CanvasHelper extends Encodable {
    width: number;
    height: number;
    /**
     * The steps to apply to the canvas.
     */
    steps: ContextManipulationStep[];
    private _canvas;
    /**
     * Creates a new CanvasHelper instance.
     * @param width The width of the canvas
     * @param height The height of the canvas
     */
    constructor(width: number, height: number);
    /**
     * Returns the canvas instance by applying the steps.
     */
    getFinalCanvas(): Promise<Canvas>;
    /**
     * Processes the steps and applies them to the canvas.
     */
    abstract process(canvas: Canvas, ctx: SKRSContext2D): Promise<void>;
}

declare class ImageFilterer extends CanvasHelper {
    #private;
    /**
     * Draws the image to the canvas.
     * @param image The image to draw
     * @param x The x position to draw the image
     * @param y The y position to draw the image
     * @param [width] The width of the image
     * @param [height] The height of the image
     */
    drawImage(image: ImageSource, x?: number, y?: number, width?: number, height?: number): this;
    /**
     * Applies invert filter to the image.
     * @param value The filter intensity
     */
    invert(value: number): this;
    /**
     * Applies grayscale filter to the image.
     * @param value The filter intensity
     */
    grayscale(value?: number): this;
    /**
     * Applies sepia filter to the image.
     * @param value The filter intensity
     */
    sepia(value: number): this;
    /**
     * Applies opacity filter to the image.
     * @param value The filter intensity
     */
    opacity(value: number): this;
    /**
     * Applies saturate filter to the image.
     * @param value The filter intensity
     */
    saturate(value: number): this;
    /**
     * Applies hue-rotate filter to the image.
     * @param value The degrees to rotate
     */
    hueRotate(value: number): this;
    /**
     * Applies contrast filter to the image.
     * @param value The filter intensity
     */
    contrast(value: number): this;
    /**
     * Applies brightness filter to the image.
     * @param value The filter intensity
     */
    brightness(value: number): this;
    /**
     * Applies blur filter to the image.
     * @param value The filter intensity
     */
    blur(value: number): this;
    /**
     * Applies drop-shadow filter to the image.
     * @param config The drop-shadow config
     * @param config.x The x offset of the shadow
     * @param config.y The y offset of the shadow
     * @param config.radius The blur radius of the shadow
     * @param config.color The color of the shadow
     */
    dropShadow(config: DropShadowConfig): this;
    /**
     * Renders the applied filters to the canvas.
     * @param canvas The canvas to render the filters to
     * @param ctx The canvas context
     */
    process(canvas: Canvas, ctx: SKRSContext2D): Promise<void>;
}
interface DropShadowConfig {
    x: number;
    y: number;
    radius: number;
    color: string;
}

declare class CanvasImage extends ImageFilterer {
    #private;
    source: ImageSource;
    /**
     * Creates a new CanvasImage instance.
     * @param source The image source
     * @param [width] The width of the image
     * @param [height] The height of the image
     */
    constructor(source: ImageSource, width?: number, height?: number);
    /**
     * Draws the image to the canvas.
     * @param x The x position to draw the image
     * @param y The y position to draw the image
     * @param [width] The width of the image
     * @param [height] The height of the image
     */
    draw(x?: number, y?: number, width?: number, height?: number): this;
    /**
     * Draws the image to the canvas with a circle clip.
     * @param [width] The width of the image
     * @param [height] The height of the image
     */
    circle(width?: number, height?: number): this;
    /**
     * Draws pixelated image to the canvas.
     * @param [pixels=5] The amount of pixels to use
     */
    pixelate(pixels?: number): this;
    /**
     * Saves the canvas context state.
     */
    save(): this;
    /**
     * Restores the last saved canvas context state.
     */
    restore(): this;
    /**
     * Returns the canvas instance by applying the steps.
     */
    getFinalCanvas(): Promise<Canvas>;
}

declare class ImageManipulator extends CanvasImage {
    #private;
    /**
     * Rotates the canvas.
     */
    rotate(degrees: number): this;
    /**
     * Flips the canvas.
     * @param axis The axis to flip, `x` or `y`.
     */
    flip(axis: "x" | "y"): void;
    /**
     * Scales the canvas.
     * @param x The x scale
     * @param y The y scale
     */
    scale(x: number, y: number): void;
    /**
     * Translates the canvas.
     * @param x The x position to translate
     * @param y The y position to translate
     */
    translate(x: number, y: number): void;
    /**
     * Erases a part of the canvas.
     * @param x The x position to erase
     * @param y The y position to erase
     * @param width The width of the area to erase
     * @param height The height of the area to erase
     */
    erase(x: number, y: number, width: number, height: number): void;
    /**
     * Applies a transform to the canvas.
     */
    transform(a: number, b: number, c: number, d: number, e: number, f: number): void;
    /**
     * Resets the transform of the canvas.
     */
    resetTransform(): void;
    /**
     * Applies a circular clip to the image.
     * @param width The width of the image
     * @param height The height of the image
     */
    circularize(width: number, height: number): void;
    /**
     * Processes the steps and applies them to the canvas.
     * @param canvas The canvas to apply the steps to
     * @param ctx The canvas context to apply the steps to
     */
    process(canvas: Canvas, ctx: SKRSContext2D): Promise<void>;
}

type ImageGeneratorImplementor = {
    [K in Lowercase<Exclude<keyof typeof TemplateFactory, "Triggered">>]: (...args: Parameters<(typeof TemplateFactory)[Capitalize<K>]>) => Promise<Buffer>;
};
interface CanvacordFactory extends ImageGeneratorImplementor {
    /**
     * Creates a new ImageFilterer instance.
     * @param width The width of the image
     * @param height The height of the image
     */
    filters(width: number, height: number): ImageFilterer;
    /**
     * Generates Triggered gif with the provided image.
     * @param image The image to use
     * @param [asBuffer] Whether to return a buffer instead of a stream
     * @returns The generated gif
     */
    triggered(image: ImageSource): Promise<Readable>;
    /**
     * Generates Triggered gif with the provided image.
     * @param image The image to use
     * @param [asBuffer] Whether to return a buffer instead of a stream
     * @returns The generated gif
     */
    triggered(image: ImageSource, asBuffer: false): Promise<Readable>;
    /**
     * Generates Triggered gif with the provided image.
     * @param image The image to use
     * @param [asBuffer] Whether to return a buffer instead of a stream
     * @returns The generated gif
     */
    triggered(image: ImageSource, asBuffer: true): Promise<Buffer>;
    /**
     * Generates Triggered gif with the provided image.
     * @param image The image to use
     * @param [asBuffer] Whether to return a buffer instead of a stream
     * @returns The generated gif
     */
    triggered(image: ImageSource, asBuffer?: boolean): Promise<Readable | Buffer>;
}
interface CanvacordInit {
    /**
     * The width of the image. Defaults to `-1` (auto).
     */
    width?: number;
    /**
     * The height of the image. Defaults to `-1` (auto).
     */
    height?: number;
}
/**
 * Creates a new Canvacord image processor.
 * @param source The image source to use
 * @param options The options to use
 * @returns The image processor
 */
declare function CanvacordConstructor(source: ImageSource, options?: CanvacordInit): CanvasImage;
type Canvacord = CanvacordFactory & typeof CanvacordConstructor;
/**
 * Creates a new Canvacord image processor.
 * @param source The image source to use
 * @param options The options to use
 * @returns The image processor
 */
declare const canvacord: Canvacord;

export { BuildFormat, Builder, BuilderBuildOptions, BuilderOptionsManager, BuilderTemplate, BuiltInGraphemeProvider, CSSPropertiesLike, Canvacord, CanvacordFactory, CanvacordInit, CanvasHelper, CanvasImage, ContextManipulationStep, CustomGenerationStep, DropShadowConfig, Element, ElementInit, EmojiCache, Encodable, EncodingFormat, Font, FontFactory, Fonts, GraphemeProvider, IImageGenerationTemplate, ImageFactory, ImageFilterer, ImageGen, ImageGenerationStep, ImageGenerationTemplate, ImageGeneratorImplementor, ImageManipulator, ImageSource, ImgenStep, JSX$1 as JSX, LeaderboardBuilder, LeaderboardProps, LeaderboardVariants, LoadImageOptions, Node, RankCardBuilder, Stylable, StyleSheet, TemplateFactory, TemplateImage, TextGenerationStep, canvacord, createCanvasImage, createEmojiProvider, createImageGenerator, createTemplate, loadImage, performObjectCleanup, render };
